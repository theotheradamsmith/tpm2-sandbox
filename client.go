package main

import (
	"crypto"
	"crypto/rand"
	"crypto/sha256"
	"crypto/x509"
	"encoding/asn1"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"math/big"
	"os"
	"os/exec"

	"github.com/google/go-tpm/tpm2"
	"github.com/google/go-tpm/tpmutil"
)

const (
	// Defined in "Registry of reserved TPM 2.0 handles and localities", and checked on a glinux machine.
	ekHandle   = 0x81010001
	srkHandle  = 0x81000001
	akHandle   = 0x81008001
	appkHandle = 0x81008002

	devTPM = "/dev/tpmrm0"
)

func certifyAppK(f io.ReadWriteCloser, hash []byte, ticket tpm2.Ticket) error {
	// To certify the new key, call CertifyCreation, passing the AK as the signing object.
	// This returns an attestation and a signature
	akTPMPub, _, _, err := tpm2.ReadPublic(f, akHandle)
	if err != nil {
		log.Println("Failed to read AK pub")
		return err
	}
	sigParams := *akTPMPub.ECCParameters.Sign
	attestData, sigData, err := tpm2.CertifyCreation(f, "", appkHandle, akHandle, nil, hash, sigParams, ticket)
	if err != nil {
		log.Println("Failed to certify AppK creation")
		return err
	}

	// Write attestation and signature to disk
	if err := os.WriteFile(pathUserPublic+fileAppKAttestDat, attestData, 0644); err != nil {
		log.Println("Failed to write appk.attestation")
		return err
	}
	if err := os.WriteFile(pathUserPublic+fileAppKAttestSig, sigData, 0644); err != nil {
		log.Println("Failed to write appk.attestation.sig")
		return err
	}

	return nil
}

func cleanClient() {
	// Cleaning persistent handles
	f, err := tpm2.OpenTPM(devTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	if err := tpm2.EvictControl(f, "", tpm2.HandleOwner, appkHandle, appkHandle); err != nil {
		log.Printf("Unable to evict AppK: %v", err)
	}
	if err := tpm2.EvictControl(f, "", tpm2.HandleOwner, akHandle, akHandle); err != nil {
		log.Printf("Unable to evict AK: %v", err)
	}
	if err := tpm2.EvictControl(f, "", tpm2.HandleOwner, srkHandle, srkHandle); err != nil {
		log.Printf("Unable to evict SRK: %v", err)
	}
	if err := tpm2.EvictControl(f, "", tpm2.HandleEndorsement, ekHandle, ekHandle); err != nil {
		log.Printf("Unable to evict EK: %v", err)
	}
}

func cliActivateCredential(credBlob []byte, encSecret []byte) ([]byte, error) {
	/*
		The EK passes the challenge by returning the decrypted secret to the CA.
		During this process, it verifies the named credential is bound to the same
		TPM. Because our EK uses an authPolicy, we have to configure a session and
		authenticate in order to use it. In this case the policy is generated by
		TPM2_PolicySecret(TPM_RH_ENDORSEMENT), so we execute the same command
		to match the digest
	*/
	f, err := tpm2.OpenTPM(devTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	session, _, err := tpm2.StartAuthSession(f,
		tpm2.HandleNull,
		tpm2.HandleNull,
		make([]byte, 16),
		nil,
		tpm2.SessionPolicy,
		tpm2.AlgNull,
		tpm2.AlgSHA256)
	if err != nil {
		log.Println("Error creating auth session")
		return nil, err
	}

	auth := tpm2.AuthCommand{Session: tpm2.HandlePasswordSession, Attributes: tpm2.AttrContinueSession}
	if _, _, err := tpm2.PolicySecret(f, tpm2.HandleEndorsement, auth, session, nil, nil, nil, 0); err != nil {
		log.Println("Policy secret failed")
		return nil, err
	}

	// Get the EK public key
	/*
		ekCtx, err := os.ReadFile(pathUserInternal + "ek.ctx")
		if err != nil {
			log.Println("Unable to read ek.ctx")
			return nil, err
		}
		ek, err := tpm2.ContextLoad(f, ekCtx)
		if err != nil {
			log.Println("Unable to load EK")
			return nil, err
		}
	*/

	auths := []tpm2.AuthCommand{auth, {Session: session, Attributes: tpm2.AttrContinueSession}}
	//out, err := tpm2.ActivateCredentialUsingAuth(f, auths, akHandle, ek, credBlob[2:], encSecret[2:])
	out, err := tpm2.ActivateCredentialUsingAuth(f, auths, akHandle, ekHandle, credBlob[2:], encSecret[2:])
	if err != nil {
		log.Println("Failed to activate credential")
		return nil, err
	}
	fmt.Printf("%s\n", out)
	return out, nil
}

func createAK() error {
	fmt.Println("Generating AK...")
	f, err := tpm2.OpenTPM(devTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	privBlob, pubBlob, _, _, _, err := tpm2.CreateKey(f, srkHandle, tpm2.PCRSelection{}, "", "", defaultAKTemplate)
	if err != nil {
		log.Println("Failed to create AK")
		return err
	}
	ak, nameData, err := tpm2.Load(f, srkHandle, "", pubBlob, privBlob)
	if err != nil {
		log.Println("Failed to load AK")
		return err
	}

	// Persist the Key
	if err := tpm2.EvictControl(f, "", tpm2.HandleOwner, ak, akHandle); err != nil {
		log.Println("Failed to make AK persistent")
		return err
	}

	// Store AK context
	akCtx, err := tpm2.ContextSave(f, ak)
	if err != nil {
		log.Println("Failed to generate AK ctx")
		return err
	}
	if err := os.WriteFile(pathUserInternal+"ak.ctx", akCtx, 0644); err != nil {
		log.Println("Failed to save AK ctx")
		return err
	}

	// Store the AK name, which is a hash of the public key blob
	if err := os.WriteFile(pathUserPublic+"ak.name", nameData, 0644); err != nil {
		log.Println("Failed to write ak.name")
		return err
	}

	// Store the AK public key blob, which includes content such as the key attributes
	if err := os.WriteFile(pathUserPublic+fileAKPubBlob, pubBlob, 0644); err != nil {
		log.Println("Failed to write ak.pub.tpmt")
		return err
	}

	// Store AK public key
	akTPMPub, _, _, err := tpm2.ReadPublic(f, ak)
	if err != nil {
		log.Fatalf("read ak public: %v", err)
	}
	akPub, err := akTPMPub.Key()
	if err != nil {
		log.Fatalf("decode ak public key: %v", err)
	}
	b, err := storePublicKey("ak", akPub)
	if err != nil {
		log.Fatalf("Unable to store AK public key")
	}
	return pem.Encode(os.Stdout, b)
}

func createAppK() error {
	fmt.Println("Generating Application Key...")
	f, err := tpm2.OpenTPM(devTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	// Create and load AppK
	privBlob, pubBlob, _, hash, ticket, err := tpm2.CreateKey(f, srkHandle, tpm2.PCRSelection{}, "", "", defaultAppKTemplate)
	if err != nil {
		log.Println("Failed to create AppK")
		return err
	}
	appk, nameData, err := tpm2.Load(f, srkHandle, "", pubBlob, privBlob)
	if err != nil {
		log.Println("Failed to load AppK")
		return err
	}

	// Persist AppK
	if err := tpm2.EvictControl(f, "", tpm2.HandleOwner, appk, appkHandle); err != nil {
		log.Println("Failed to make AppK persistent")
		return err
	}

	// Certify AppK
	if err := certifyAppK(f, hash, ticket); err != nil {
		log.Println("Unable to certify AppK")
		return err
	}

	// Store AppK context
	appkCtx, err := tpm2.ContextSave(f, appk)
	if err != nil {
		log.Fatalf("Failed to generate AppK context: %v", err)
	}
	if err := os.WriteFile(pathUserInternal+"appk.ctx", appkCtx, 0644); err != nil {
		log.Fatalf("Failed to save AppK context: %v", err)
	}

	// Store the AppK name, which is a hash of the public key blob
	if err := os.WriteFile(pathUserPublic+"appk.name", nameData, 0644); err != nil {
		log.Println("Failed to write appk.name")
		return err
	}

	// Store the AppK public key blob, which includes content such as the key attributes
	if err := os.WriteFile(pathUserPublic+fileAppKPubBlob, pubBlob, 0644); err != nil {
		log.Println("Failed to write appk.pub.tpmt")
		return err
	}

	// Store appk.pub and PEM, and print PEM to stdout
	appkTPMPub, err := tpm2.DecodePublic(pubBlob)
	if err != nil {
		log.Println("Failed to decode AppK blob")
		return err
	}
	appkPub, err := appkTPMPub.Key()
	if err != nil {
		log.Println("Failed to get AppK public key")
		return err
	}
	b, err := storePublicKey("appk", appkPub)
	if err != nil {
		log.Println("Unable to store AppK public key")
		return err
	}
	return pem.Encode(os.Stdout, b)
}

func createEK() error {
	fmt.Println("Generating EK...")
	f, err := tpm2.OpenTPM(devTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	ek, pub, err := tpm2.CreatePrimary(f, tpm2.HandleEndorsement, tpm2.PCRSelection{}, "", "", defaultEKTemplate)
	if err != nil {
		log.Println("creating EK")
		return err
	}

	// Save EK context
	handle, err := tpm2.ContextSave(f, ek)
	if err != nil {
		log.Println("Failed to generate EK context")
		return err
	}
	if err := os.WriteFile(pathUserInternal+"ek.ctx", handle, 0644); err != nil {
		log.Println("Failed to save EK context")
		return err
	}

	// Persist the Key
	if err := tpm2.EvictControl(f, "", tpm2.HandleEndorsement, ek, ekHandle); err != nil {
		log.Println("Failed to make EK persistent")
		return err
	}

	// Pull the EK certificate (don't think they've implemented this in go-tpm)
	cmd := exec.Command("tpm2_getekcertificate", "-o", "RSA_EK_cert.bin", "-o", "ECC_EK_cert.bin")
	if _, err := cmd.Output(); err != nil {
		log.Printf("unable to run tpm2_getekcertificate: %v", err)
	}

	// Store EK public key
	b, err := storePublicKey("ek", pub)
	if err != nil {
		return fmt.Errorf("unable to store EK public key: %v", err)
	}

	return pem.Encode(os.Stdout, b)
}

func createSRK() error {
	fmt.Println("Generating SRK...")
	f, err := tpm2.OpenTPM(devTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	srk, pub, err := tpm2.CreatePrimary(f, tpm2.HandleOwner, tpm2.PCRSelection{}, "", "", defaultSRKTemplate)
	if err != nil {
		log.Println("creating SRK")
		return err
	}

	// Persist the Key
	if err := tpm2.EvictControl(f, "", tpm2.HandleOwner, srk, srkHandle); err != nil {
		log.Println("Failed to make SRK persistent")
		return err
	}

	// Save SRK context
	out, err := tpm2.ContextSave(f, srk)
	if err != nil {
		log.Println("Failed to generate SRK context")
		return err
	}
	if err := os.WriteFile(pathUserInternal+"srk.ctx", out, 0644); err != nil {
		log.Println("Failed to save SRK context")
		return err
	}

	// Store SRK public key
	b, err := storePublicKey("srk", pub)
	if err != nil {
		log.Println("Unable to store SRK public key")
		return err
	}

	return pem.Encode(os.Stdout, b)
}

type signer struct {
	tpm io.ReadWriter
	h   tpmutil.Handle
	pub crypto.PublicKey
}

func (s *signer) Public() crypto.PublicKey {
	return s.pub
}

func (s *signer) Sign(r io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) {
	sig, err := tpm2.Sign(s.tpm, s.h, "", digest, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("unable to sign data: %v", err)
	}
	if sig.RSA != nil {
		return sig.RSA.Signature, nil
	}
	if sig.ECC != nil {
		return asn1.Marshal(struct {
			R *big.Int
			S *big.Int
		}{sig.ECC.R, sig.ECC.S})
	}
	return nil, fmt.Errorf("unsupported signature type: %v", sig.Alg)
}

func newSigner(tpm io.ReadWriter, h tpmutil.Handle) (*signer, error) {
	tpmPub, _, _, err := tpm2.ReadPublic(tpm, h)
	if err != nil {
		return nil, fmt.Errorf("unable to read public blob: %v", err)
	}
	pub, err := tpmPub.Key()
	if err != nil {
		return nil, fmt.Errorf("unable to decode public key: %v", err)
	}
	return &signer{tpm, h, pub}, nil
}

func signIID() error {
	fmt.Println("Signing IID...")
	f, err := tpm2.OpenTPM(devTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	// Create signer
	priv, err := newSigner(f, appkHandle)
	if err != nil {
		return fmt.Errorf("unable to create signer: %v", err)
	}

	// Load IID & create digest
	msg, err := os.ReadFile("iid.raw")
	if err != nil {
		return fmt.Errorf("unable to read iid.raw: %v", err)
	}
	digest := sha256.Sum256(msg)

	// Sign & write signature
	sig, err := priv.Sign(rand.Reader, digest[:], crypto.SHA256)
	if err != nil {
		return fmt.Errorf("unable to sign data: %v", err)
	}

	if err := os.WriteFile(pathUserPublic+"iid.sig", sig, 0644); err != nil {
		return fmt.Errorf("unable to write iid.sig: %v", err)
	}

	return nil
}

func storePublicKey(prefix string, pub crypto.PublicKey) (*pem.Block, error) {
	pubDER, err := x509.MarshalPKIXPublicKey(pub)
	if err != nil {
		log.Println("encoding public key")
		return nil, err
	}

	if err := os.WriteFile(pathUserPublic+prefix+".pub.der", pubDER, 0644); err != nil {
		log.Println("writing " + prefix + ".pub.der")
		return nil, err
	}

	b := &pem.Block{Type: "PUBLIC KEY", Bytes: pubDER}

	if err := os.WriteFile(pathUserPublic+prefix+".pub.pem", pem.EncodeToMemory(b), 0644); err != nil {
		log.Println("writing " + prefix + ".pub.pem")
		return nil, err
	}

	return b, nil
}

/*
	ekTPMPub, _, _, err := tpm2.ReadPublic(f, ek)
	if err != nil {
		log.Fatalf("read ek public: %v", err)
	}
	ekPub, err := ekTPMPub.Key()
	if err != nil {
		log.Fatalf("decode ek public key: %v", err)
	}
*/
/*
	akTPMPub, err := tpm2.DecodePublic(pubBlob)
	if err != nil {
		log.Println("FAILED TEST PUBLIC DECODE")
		return err
	}
*/
