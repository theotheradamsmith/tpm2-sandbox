package main

import (
	"bytes"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"log"
	"os"

	"github.com/google/go-tpm/tpm2"
	"github.com/google/go-tpm/tpm2/credactivation"
	"github.com/google/go-tpm/tpmutil"
)

func credentialActivation() error {
	akNameData, err := os.ReadFile("ak.name")
	if err != nil {
		log.Println("Unable to open ak.name")
		return err
	}
	akPubBlob, err := os.ReadFile("ak.pub.blob")
	if err != nil {
		log.Println("Unable to open ak.pub.blob")
		return err
	}

	credBlob, encSecret, err := caChallenge(akNameData, akPubBlob)
	if err != nil {
		log.Println("CA failed to generate challenge")
		return err
	}
	if err := activateCredential(credBlob, encSecret); err != nil {
		log.Println("Failed to activate credential")
		return err
	}

	return nil
}

func caChallenge(nameData []byte, pubBlob []byte) ([]byte, []byte, error) {
	/*
		The challenge asks the EK to verify another key name is also loaded into the TPM.
		Because key names are digests of the public key blob, the CA can verify public key
		attributes and reject any that don't match expectations.

		Included in the encrypted blob is a secret that the CA tracks with the challenge.
	*/

	// Verify digest matches the public blob that was provided
	name, err := tpm2.DecodeName(bytes.NewBuffer(nameData))
	if err != nil {
		log.Fatalf("unpacking name: %v", err)
	}
	if name.Digest == nil {
		log.Fatalf("name was not a digest")
	}
	h, err := name.Digest.Alg.Hash()
	if err != nil {
		log.Fatalf("failed to get name hash: %v", err)
	}
	pubHash := h.New()
	pubHash.Write(pubBlob)
	pubDigest := pubHash.Sum(nil)
	if !bytes.Equal(name.Digest.Value, pubDigest) {
		log.Fatalf("name was not for public blob")
	}

	// Inspect key attributes
	pub, err := tpm2.DecodePublic(pubBlob)
	if err != nil {
		log.Fatalf("decode public blob: %v", err)
	}
	fmt.Printf("Key attributes: 0x08%x\n", pub.Attributes)

	// Generate a challenge for the name.
	//
	// Note that some TPMs enforce a maximum secret size of 32 bytes
	ekPubDer, err := os.ReadFile("ek.pub")
	if err != nil {
		log.Println("Unable to read ek.pub")
		return nil, nil, err
	}
	ekPub, err := x509.ParsePKIXPublicKey(ekPubDer)

	secret := []byte("Aren't cats just the best?")
	symBlockSize := 16
	credBlob, encSecret, err := credactivation.Generate(name.Digest, ekPub, symBlockSize, secret)
	if err != nil {
		log.Println("Unable to generate credential")
		return nil, nil, err
	}

	return credBlob, encSecret, nil
}

func activateCredential(credBlob []byte, encSecret []byte) error {
	/*
		The EK passes the challenge by returning the decrypted secret to the CA.
		During this process, it verifies the named credential is bound to the same
		TPM. Because our EK uses an authPolicy, we have to configure a session and
		authenticate in order to use it. In this case the policy is generated by
		TPM2_PolicySecret(TPM_RH_ENDORSEMENT), so we execute the same command
		to match the digest
	*/
	f, err := tpm2.OpenTPM(pathTPM)
	if err != nil {
		log.Fatalf("opening tpm: %v", err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatalf("closing tpm: %v", err)
		}
	}()

	session, _, err := tpm2.StartAuthSession(f,
		tpm2.HandleNull,
		tpm2.HandleNull,
		make([]byte, 16),
		nil,
		tpm2.SessionPolicy,
		tpm2.AlgNull,
		tpm2.AlgSHA256)
	if err != nil {
		log.Println("Error creating auth session")
		return err
	}

	auth := tpm2.AuthCommand{Session: tpm2.HandlePasswordSession, Attributes: tpm2.AttrContinueSession}
	if _, _, err := tpm2.PolicySecret(f, tpm2.HandleEndorsement, auth, session, nil, nil, nil, 0); err != nil {
		log.Println("Policy secret failed")
		return err
	}

	// Get the EK public key
	ekCtx, err := os.ReadFile("ek.ctx")
	if err != nil {
		log.Println("Unable to read ek.ctx")
		return err
	}
	ek, err := tpm2.ContextLoad(f, ekCtx)
	if err != nil {
		log.Println("Unable to load EK")
		return err
	}

	// Get the AK public key
	akCtx, err := os.ReadFile("ak.ctx")
	if err != nil {
		log.Println("Unable to read ak.ctx")
		return err
	}
	ak, err := tpm2.ContextLoad(f, akCtx)
	if err != nil {
		log.Println("Unable to load AK")
		return err
	}

	auths := []tpm2.AuthCommand{auth, {Session: session, Attributes: tpm2.AttrContinueSession}}
	out, err := tpm2.ActivateCredentialUsingAuth(f, auths, ak, ek, credBlob[2:], encSecret[2:])
	if err != nil {
		log.Fatalf("activate credential: %v", err)
	}
	fmt.Printf("%s\n", out)
	return nil
}

func getAttestedCreationNameDigest(attestData []byte) (tpmutil.U16Bytes, error) {
	a, err := tpm2.DecodeAttestationData(attestData)
	if err != nil {
		return nil, err
	}

	return a.AttestedCreationInfo.Name.Digest.Value, nil
}

func attestation_verification_test(p string, a string) {
	pubBlob, err := os.ReadFile(p)
	if err != nil {
		fmt.Printf("Error reading file: %v\n", err)
		return
	}
	fmt.Printf("Contents of pubBlob: %x\n", pubBlob)
	tpmPub, err := tpm2.DecodePublic(pubBlob)
	if err != nil {
		log.Fatalf("decode public blob: %v", err)
	}
	pub, err := tpmPub.Key()
	if err != nil {
		log.Fatalf("decode public key: %v", err)
	}
	pubDER, err := x509.MarshalPKIXPublicKey(pub)
	if err != nil {
		log.Fatalf("encoding public key: %v", err)
	}
	b := &pem.Block{Type: "PUBLIC KEY", Bytes: pubDER}
	fmt.Printf("Key attributes: 0x%08x\n", tpmPub.Attributes)
	pem.Encode(os.Stdout, b)

	attestData, err := os.ReadFile(a)
	if err != nil {
		fmt.Printf("Error reading file: %v\n", err)
		return
	}
	attestedNameDigest, err := getAttestedCreationNameDigest(attestData)
	if err != nil {
		fmt.Printf("Error parsing attestation: %v\n", err)
	}

	pubDigest := sha256.Sum256(pubBlob)
	if !bytes.Equal(attestedNameDigest, pubDigest[:]) {
		fmt.Printf("\n\nAttested Name: %v\n", attestedNameDigest)
		fmt.Printf("PubDigest Val: %v\n\n", pubDigest[:])
		log.Fatalf("attestation was not for public blob")
	} else {
		fmt.Println("Attestation was valid")
	}
}
